# -*- coding: utf-8 -*-
"""RSA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PMbLoonta8gEqOKfCxLYpXTN2K9as0sL
"""

import random
import math
import sys

class RSAEncryption:
    def __init__(self):
        self.public_key = None
        self.private_key = None
        self.n = None

    def is_prime(self, num):
        """Check if a number is prime using trial division"""
        if num < 2:
            return False
        if num == 2:
            return True
        if num % 2 == 0:
            return False

        for i in range(3, int(math.sqrt(num)) + 1, 2):
            if num % i == 0:
                return False
        return True

    def generate_prime(self, min_val=100, max_val=1000):
        """Generate a random prime number within the given range"""
        while True:
            num = random.randint(min_val, max_val)
            if self.is_prime(num):
                return num

    def gcd(self, a, b):
        """Calculate Greatest Common Divisor using Euclidean algorithm"""
        while b:
            a, b = b, a % b
        return a

    def mod_inverse(self, e, phi):
        """Calculate modular multiplicative inverse using Extended Euclidean Algorithm"""
        def extended_gcd(a, b):
            if a == 0:
                return b, 0, 1
            gcd, x1, y1 = extended_gcd(b % a, a)
            x = y1 - (b // a) * x1
            y = x1
            return gcd, x, y

        gcd, x, _ = extended_gcd(e, phi)
        if gcd != 1:
            raise ValueError("Modular inverse does not exist")
        return (x % phi + phi) % phi

    def generate_keys(self, key_size=512):
        """Generate RSA public and private key pairs"""
        print("🔑 Generating RSA Keys...")

        # Step 1: Generate two distinct prime numbers
        if key_size == 512:
            min_prime, max_prime = 100, 500
        elif key_size == 1024:
            min_prime, max_prime = 500, 1000
        else:
            min_prime, max_prime = 50, 200

        p = self.generate_prime(min_prime, max_prime)
        q = self.generate_prime(min_prime, max_prime)

        # Ensure p and q are different
        while p == q:
            q = self.generate_prime(min_prime, max_prime)

        print(f"Prime p: {p}")
        print(f"Prime q: {q}")

        # Step 2: Calculate n = p * q
        self.n = p * q
        print(f"n (p × q): {self.n}")

        # Step 3: Calculate Euler's totient function φ(n) = (p-1)(q-1)
        phi = (p - 1) * (q - 1)
        print(f"φ(n): {phi}")

        # Step 4: Choose e such that 1 < e < φ(n) and gcd(e, φ(n)) = 1
        e = 65537  # Common choice for e
        if e >= phi or self.gcd(e, phi) != 1:
            e = 3
            while e < phi:
                if self.gcd(e, phi) == 1:
                    break
                e += 2

        print(f"Public exponent e: {e}")

        # Step 5: Calculate d, the modular multiplicative inverse of e
        d = self.mod_inverse(e, phi)
        print(f"Private exponent d: {d}")

        # Store keys
        self.public_key = (e, self.n)
        self.private_key = (d, self.n)

        print("✅ Keys generated successfully!")
        print(f"📢 Public Key: (e={e}, n={self.n})")
        print(f"🔐 Private Key: (d={d}, n={self.n})")
        print("-" * 50)

    def encrypt_message(self, message, public_key=None):
        """Encrypt a message using RSA public key"""
        if public_key is None:
            public_key = self.public_key

        if public_key is None:
            raise ValueError("No public key available. Generate keys first.")

        e, n = public_key

        # Convert message to list of ASCII values
        encrypted_chars = []

        print(f"🔒 Encrypting message: '{message}'")
        print("Character-by-character encryption:")

        for char in message:
            # Get ASCII value
            m = ord(char)

            # Encrypt: c = m^e mod n
            c = pow(m, e, n)
            encrypted_chars.append(c)

            print(f"  '{char}' (ASCII: {m}) → {c}")

        return encrypted_chars

    def decrypt_message(self, encrypted_message, private_key=None):
        """Decrypt a message using RSA private key"""
        if private_key is None:
            private_key = self.private_key

        if private_key is None:
            raise ValueError("No private key available. Generate keys first.")

        d, n = private_key

        decrypted_chars = []

        print("🔓 Decrypting message:")
        print("Character-by-character decryption:")

        for c in encrypted_message:
            # Decrypt: m = c^d mod n
            m = pow(c, d, n)

            # Convert back to character
            char = chr(m)
            decrypted_chars.append(char)

            print(f"  {c} → {m} (ASCII) → '{char}'")

        return ''.join(decrypted_chars)

    def sign_message(self, message):
        """Create a digital signature for a message"""
        if self.private_key is None:
            raise ValueError("No private key available. Generate keys first.")

        # Simple hash function (sum of ASCII values mod n)
        message_hash = sum(ord(char) for char in message) % self.n

        # Sign with private key
        d, n = self.private_key
        signature = pow(message_hash, d, n)

        print(f"📝 Message hash: {message_hash}")
        print(f"✍️  Digital signature: {signature}")

        return signature, message_hash

    def verify_signature(self, message, signature, public_key=None):
        """Verify a digital signature"""
        if public_key is None:
            public_key = self.public_key

        if public_key is None:
            raise ValueError("No public key available.")

        # Calculate message hash
        message_hash = sum(ord(char) for char in message) % self.n

        # Verify signature with public key
        e, n = public_key
        verified_hash = pow(signature, e, n)

        is_valid = message_hash == verified_hash

        print(f"📝 Original message hash: {message_hash}")
        print(f"🔍 Verified hash: {verified_hash}")
        print(f"✅ Signature valid: {is_valid}")

        return is_valid

def display_menu():
    """Display the main menu"""
    print("\n" + "="*60)
    print("🔐 RSA ENCRYPTION/DECRYPTION SYSTEM 🔐")
    print("="*60)
    print("1. 🔑 Generate New RSA Keys")
    print("2. 🔒 Encrypt a Message")
    print("3. 🔓 Decrypt a Message")
    print("4. ✍️  Sign a Message")
    print("5. 🔍 Verify a Signature")
    print("6. 📋 Display Current Keys")
    print("7. 🧮 RSA Mathematics Demo")
    print("8. ❌ Exit")
    print("="*60)

def mathematics_demo():
    """Demonstrate RSA mathematics with small numbers"""
    print("\n🧮 RSA MATHEMATICS DEMONSTRATION")
    print("="*50)

    # Use small primes for easy understanding
    p, q = 7, 11
    n = p * q
    phi = (p - 1) * (q - 1)
    e = 3  # Small public exponent

    # Calculate d
    def extended_gcd(a, b):
        if a == 0:
            return b, 0, 1
        gcd, x1, y1 = extended_gcd(b % a, a)
        x = y1 - (b // a) * x1
        y = x1
        return gcd, x, y

    _, d, _ = extended_gcd(e, phi)
    d = (d % phi + phi) % phi

    print(f"Step 1: Choose primes p = {p}, q = {q}")
    print(f"Step 2: Calculate n = p × q = {p} × {q} = {n}")
    print(f"Step 3: Calculate φ(n) = (p-1)(q-1) = {p-1} × {q-1} = {phi}")
    print(f"Step 4: Choose e = {e} (coprime to φ(n))")
    print(f"Step 5: Calculate d ≡ e⁻¹ (mod φ(n)) = {d}")
    print(f"\nPublic Key: (e={e}, n={n})")
    print(f"Private Key: (d={d}, n={n})")

    # Demonstrate encryption/decryption
    message = 5  # Simple number
    print(f"\nDemo with message m = {message}:")

    # Encryption: c = m^e mod n
    ciphertext = pow(message, e, n)
    print(f"Encryption: c = m^e mod n = {message}^{e} mod {n} = {ciphertext}")

    # Decryption: m = c^d mod n
    decrypted = pow(ciphertext, d, n)
    print(f"Decryption: m = c^d mod n = {ciphertext}^{d} mod {n} = {decrypted}")

    print(f"✅ Original message recovered: {message} = {decrypted}")

def main():
    rsa = RSAEncryption()
    encrypted_data = None
    signature_data = None

    while True:
        display_menu()

        try:
            choice = input("Enter your choice (1-8): ").strip()

            if choice == '1':
                print("\n🔑 KEY GENERATION")
                print("-" * 30)
                key_size = input("Enter key size (256/512/1024) [default: 512]: ").strip()
                if not key_size:
                    key_size = 512
                else:
                    key_size = int(key_size)

                rsa.generate_keys(key_size)

            elif choice == '2':
                if rsa.public_key is None:
                    print("❌ Please generate keys first!")
                    continue

                print("\n🔒 MESSAGE ENCRYPTION")
                print("-" * 30)
                message = input("Enter message to encrypt: ")

                if not message:
                    print("❌ Empty message!")
                    continue

                encrypted_data = rsa.encrypt_message(message)
                print(f"\n✅ Encrypted message: {encrypted_data}")

            elif choice == '3':
                if rsa.private_key is None:
                    print("❌ Please generate keys first!")
                    continue

                if encrypted_data is None:
                    print("❌ No encrypted message available!")
                    print("You can manually enter encrypted data:")
                    try:
                        encrypted_input = input("Enter encrypted data (comma-separated numbers): ")
                        encrypted_data = [int(x.strip()) for x in encrypted_input.split(',')]
                    except ValueError:
                        print("❌ Invalid format!")
                        continue

                print("\n🔓 MESSAGE DECRYPTION")
                print("-" * 30)

                decrypted_message = rsa.decrypt_message(encrypted_data)
                print(f"\n✅ Decrypted message: '{decrypted_message}'")

            elif choice == '4':
                if rsa.private_key is None:
                    print("❌ Please generate keys first!")
                    continue

                print("\n✍️  MESSAGE SIGNING")
                print("-" * 30)
                message = input("Enter message to sign: ")

                if not message:
                    print("❌ Empty message!")
                    continue

                signature, msg_hash = rsa.sign_message(message)
                signature_data = (message, signature, msg_hash)

            elif choice == '5':
                if rsa.public_key is None:
                    print("❌ Please generate keys first!")
                    continue

                print("\n🔍 SIGNATURE VERIFICATION")
                print("-" * 30)

                if signature_data is None:
                    print("❌ No signature available!")
                    message = input("Enter original message: ")
                    try:
                        signature = int(input("Enter signature: "))
                    except ValueError:
                        print("❌ Invalid signature format!")
                        continue
                else:
                    message, signature, _ = signature_data
                    print(f"Using stored signature for message: '{message}'")

                rsa.verify_signature(message, signature)

            elif choice == '6':
                print("\n📋 CURRENT KEYS")
                print("-" * 30)
                if rsa.public_key and rsa.private_key:
                    e, n = rsa.public_key
                    d, _ = rsa.private_key
                    print(f"📢 Public Key:  (e={e}, n={n})")
                    print(f"🔐 Private Key: (d={d}, n={n})")
                else:
                    print("❌ No keys generated yet!")

            elif choice == '7':
                mathematics_demo()

            elif choice == '8':
                print("\n👋 Thank you for using RSA Encryption System!")
                print("🔐 Stay secure! 🔐")
                sys.exit(0)

            else:
                print("❌ Invalid choice! Please enter 1-8.")

        except KeyboardInterrupt:
            print("\n\n👋 Goodbye!")
            sys.exit(0)
        except Exception as e:
            print(f"❌ An error occurred: {str(e)}")

        input("\nPress Enter to continue...")

if __name__ == "__main__":
    print("🚀 Starting RSA Encryption System...")
    main()